import logging
import sys # Retained for now, though direct sys.stdout usage will be conditional
from ..pocketflow import AsyncNode
from ..commands.io import AbstractOutputHandler # Added import

logger = logging.getLogger(__name__)

class PrintFinalAnswerNode(AsyncNode):
    def __init__(self, output_handler: AbstractOutputHandler = None, prints_directly=False, max_retries=1, wait=0): # Changed terminal_app_instance to output_handler
        super().__init__(max_retries=max_retries, wait=wait)
        self.output_handler = output_handler # Stored output_handler
        self.prints_directly = prints_directly
        logger.debug(
            f"PrintFinalAnswerNode initialized with max_retries={self.max_retries}, "
            f"wait={self.wait}s, prints_directly={self.prints_directly}, has_output_handler={self.output_handler is not None}"
        )

    async def prep_async(self, shared_data: dict):
        """
        Retrieves the final answer and messages from the shared store.
        """
        final_answer = shared_data.get('final_answer', 'Info: No final answer was generated by the previous node.')
        messages = shared_data.get('messages', [])
        logger.debug(f"Prep: Retrieved final_answer: '{final_answer}'")
        return {"final_answer": final_answer, "messages": messages}

    async def exec_async(self, prep_res: dict):
        """
        Processes the final answer. If configured, prints directly via output_handler.
        Otherwise, ensures the answer is ready for the mode to display.
        """
        final_answer_to_process = prep_res["final_answer"]
        
        if self.prints_directly and self.output_handler: # Changed self.terminal_app to self.output_handler
            self.output_handler.send_message(f"Agent: {final_answer_to_process}", style="bold green") # Changed to use output_handler.print_text
            logger.info(f"Printed final answer directly via output_handler: {final_answer_to_process}")
        else:
            # If not printing directly, the mode is responsible for displaying shared_data['final_answer'].
            # This node confirms the answer is processed.
            logger.info(f"Final answer prepared for mode display: {final_answer_to_process}")

        return {"processed_answer": final_answer_to_process, "messages": prep_res["messages"]}

    async def post_async(self, shared_data: dict, prep_res: dict, exec_res: dict):
        """
        Updates messages in the shared store.
        The 'final_answer' in shared_data should have been set by the upstream LLMNode.
        This node primarily consumes/displays it.
        """
        updated_messages = exec_res.get("messages", []) # Ensure messages key exists
        
        # Add a system message indicating the answer was processed by this node
        system_message_content = f"Final answer '{exec_res.get('processed_answer', 'N/A')}' processed by PrintFinalAnswerNode."
        if self.prints_directly and self.output_handler: # Changed self.terminal_app to self.output_handler
            system_message_content += " (Displayed directly to terminal)"
        else:
            system_message_content += " (Prepared for mode display)"
            
        updated_messages.append({'role': 'system', 'content': system_message_content})
        
        shared_data['messages'] = updated_messages
        # shared_data['final_answer'] is assumed to be set by an upstream node (e.g., LLMNode).
        # This node's role is presentation or ensuring it's ready for presentation.

        logger.debug(f"Post: Updated messages in shared store: {shared_data['messages']}")
        return "default" # Standard action to proceed