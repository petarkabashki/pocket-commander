import logging
import sys # Required for sys.stdout.write
from ..pocketflow import AsyncNode # Corrected import

logger = logging.getLogger(__name__)

class PrintFinalAnswerNode(AsyncNode):
    def __init__(self, max_retries=1, wait=0): # Typically, printing doesn't need many retries
        super().__init__(max_retries=max_retries, wait=wait)
        logger.debug(f"PrintFinalAnswerNode initialized with max_retries={self.max_retries}, wait={self.wait}s")

    async def prep_async(self, shared):
        """
        Retrieves the final answer and messages from the shared store.
        """
        final_answer = shared.get('final_answer', 'Info: No final answer was generated by the previous node.')
        messages = shared.get('messages', [])
        logger.debug(f"Prep: Retrieved final_answer: '{final_answer}'")
        return {"final_answer": final_answer, "messages": messages}

    async def exec_async(self, prep_res):
        """
        Prints the final answer to standard output.
        """
        final_answer_to_print = prep_res["final_answer"]
        
        # The original code in main.py prints this, so this node might be redundant
        # or could be used for more structured logging/output if main.py's printing is removed.
        # For now, let's keep the print here as per the original node's intent.
        # logger.info(f"Final Answer: {final_answer_to_print}") # Using logger instead of print for consistency
        
        # The original node used sys.stdout.write, let's replicate that behavior
        # but also log it for better traceability within node logs.
        output_string = f"Final Answer (from PrintFinalAnswerNode): {final_answer_to_print}\n"
        sys.stdout.write(output_string)
        sys.stdout.flush() # Ensure it's printed immediately
        logger.info(output_string.strip()) # Log the same output

        # Return the messages to be updated in post_async
        return {"printed_answer": final_answer_to_print, "messages": prep_res["messages"]}

    async def post_async(self, shared, prep_res, exec_res):
        """
        Optionally updates messages in the shared store.
        """
        updated_messages = exec_res["messages"]
        # Add a system message indicating the answer was processed by this node
        # This helps in tracing the flow through messages.
        updated_messages.append({'role': 'system', 'content': f"Final answer processed by PrintFinalAnswerNode."})
        
        shared['messages'] = updated_messages
        # shared['final_answer'] is already set by the LLM node. This node just consumes it.

        logger.debug(f"Post: Updated messages in shared store: {shared['messages']}")
        return "default" # Standard action to proceed